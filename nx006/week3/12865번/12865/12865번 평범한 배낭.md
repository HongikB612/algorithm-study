# 12865번 평범한 배낭

난이도: 골드 5
알고리즘 분류: DP
언어: C++
주차: 2G/3주차
풀이 날짜: 2023년 3월 21일

### 목차

# 문제

[https://www.acmicpc.net/problem/12865](https://www.acmicpc.net/problem/12865)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 2 초 | 512 MB | 93456 | 34414 | 22312 | 35.318% |

### 문제

---

이 문제는 아주 평범한 배낭에 관한 문제이다.

한 달 후면 국가의 부름을 받게 되는 준서는 여행을 가려고 한다. 세상과의 단절을 슬퍼하며 최대한 즐기기 위한 여행이기 때문에, 가지고 다닐 배낭 또한 최대한 가치 있게 싸려고 한다.

준서가 여행에 필요하다고 생각하는 N개의 물건이 있다. 각 물건은 무게 W와 가치 V를 가지는데, 해당 물건을 배낭에 넣어서 가면 준서가 V만큼 즐길 수 있다. 아직 행군을 해본 적이 없는 준서는 최대 K만큼의 무게만을 넣을 수 있는 배낭만 들고 다닐 수 있다. 준서가 최대한 즐거운 여행을 하기 위해 배낭에 넣을 수 있는 물건들의 가치의 최댓값을 알려주자.

### 입력

---

첫 줄에 물품의 수 N(1 ≤ N ≤ 100)과 준서가 버틸 수 있는 무게 K(1 ≤ K ≤ 100,000)가 주어진다. 두 번째 줄부터 N개의 줄에 거쳐 각 물건의 무게 W(1 ≤ W ≤ 100,000)와 해당 물건의 가치 V(0 ≤ V ≤ 1,000)가 주어진다.

입력으로 주어지는 모든 수는 정수이다.

### 출력

---

한 줄에 배낭에 넣을 수 있는 물건들의 가치합의 최댓값을 출력한다.

### 예제 입력 1

---

```
4 7
6 13
4 8
3 6
5 12
```

### 예제 출력 1

---

```
14
```

# 풀이

평범한 배낭, 혹은 knapsack problem 이라 불리는 이 문제는 DP를 이용하는 대표적인 문제로, 두 개의 변수에 대해 2차원 DP 테이블을 만들어서 풀이한다.

top-down, bottom-up 방식 모두 풀이할 수 있는데, 여기서는 bottom-up 방식으로 풀이했다.

이 문제의 핵심 아이디어는, item을 하나씩 추가해가면서, 이 item을 **추가할 것인지 말 것인지를** 결정하는 문제이다.

실제 예시를 보면서 이해해보자.

|  | A | B | C | D |
| --- | --- | --- | --- | --- |
| value | 30 | 20 | 40 | 10 |
| weight | 1 | 2 | 3 | 4 |

이러한 입력이 있다고 가정하자.

### 주의사항: 잘못된 문제 쪼개기

DP로 문제를 푼다는 건 알겠는데, 잘못된 방법으로 이 문제를 쪼갤 수가 있음을 주의해야 한다.

예를 들어 subproblem을 구할 때 다음과 같이 구하면 망한다.

$$
F(\text{ABCD}, 5)=\max\begin{cases}
F(\text{BCD}, 4) + 30 \\
F(\text{ACD}, 3) + 20 \\
F(\text{ABD}, 2) + 40 \\
F(\text{ABC}, 1) + 10 \\
\end{cases}
$$

이런 식으로 subproblem을, ABCD 돌아가면서 하나씩 없애는 식으로 나누는 방법은 잘못된 방법이다.

왜냐면 우리의 목적은 ABCD 각각의 물건이 있는 경우와 없는 경우를 나누는 건데, 위 방법의 경우 subproblem 에서 problem으로 올라갈 때 **************************************************무조건 빠진 물건이 더해지는 방향으로 가고 있다.**************************************************

즉 여기서 만든 subproblem은 각각의 물건이 “없을” 경우의 수를 고려하지 않고 있다.

### top-down 방식

이 문제를 풀기 위해선 각각의 물건이 있는 경우와 없는 경우로 나누어야 한다.

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled.png)

그렇게 나누면 위 그림과 같이 나누게 된다. 왼쪽은 item이 있는 경우, 오른쪽이 없는 경우다.

예를 들어 둘째 줄의 F(”ABC”, 1)은 D가 있는 경우, F(”ABC”, 5)는 D가 없는 경우를 말한다.

이때 셋째 줄의 F(”AB”, -2)는 C, D가 모두 있는 경우를 뜻하는데, 이때는 subproblem의 무게가 -2가 된다(다시 해석하자면 C와 D를 합한 무게는 7인데, maxweight가 5이므로 최대치를 2 초과하는 것으로 해석할 수 있다). 무게가 음수일 수는 없으므로, 여기서 탐색을 종료하면 된다.

다시 B가 있고 없고를 각각 탐색하고, 또 A가 있고 없고를 각각 탐색하면서 재귀적으로 탐색하면 된다.

이를 점화식으로 나타내보면 $F(n, w)$ (n은 n번까지의 물건이 있다는 의미, w를 n번 물건의 무게)에 대해 다음 식이 성립한다.

$$
F(n, w)=\max\begin{cases}
F(n-1, w-w_n) + v_n \\
F(n-1, w) + 0
\end{cases}
$$

아래는 n번 째 물건이 없는 경우, 위에는 있는 경우

물건이 없는 경우는 더해지는 value가 0이고, 물건이 있는 경우 해당 물건의 가치만큼의 value를 더한다.

이를 DP 테이블로 나타내보자. 여기서 변수가 n, w 두 개이므로 이차원 배열로 만들어야 한다.

| n \ w | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| 0 - |  |  |  |  |  |  |
| 1 A |  |  |  |  |  |  |
| 2 AB |  |  |  |  |  |  |
| 3 ABC |  |  |  |  |  |  |
| 4 ABCD |  |  |  |  |  | t |

각 행의 의미는 n까지의 물건이 각각 있을 수도 없을 수도 있음을 의미한다. 

예를 들어 n=4일 때 의미는 ABCD가 모두 있을 수도 있고 없을 수도 있음을 의미한다.

각 열의 의미는 최대 무게이다.

먼저 top-down 방식으로 문제를 풀면, 우리가 찾고자 하는 값은 최대 무게가 5일 때 ABCD가 모두 있을 수 있는 경우($F(4, 5)$)이다. 이를 테이블에서 나타내면 맨 오른쪽 아래 ****************t****************이다.

이때 t를 찾기 위해, D가 있고 없는 경우를 각각 구해보면 아래 그림과 같이 된다.

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled%201.png)

이제 다시 각각 F(3, 1)과 F(3, 5)를 찾아보자.

이때 C가 없는 경우를 따질 때, F(3, -2)는 없으므로 따지지 않아도 된다.

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled%202.png)

C가 없을 수도 있을 수도 있는 경우를 따졌다(파란색). 이를 B, A까지 반복해보면

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled%203.png)

이제 초기값을 알면 되는데, 초기값의 경우 당연히 0이다.

왜냐면 행의 경우, n = 0일 때 아무 물건이 없는데 그러면 당연히 모든 value가 무게에 상관없이 0이다.

열의 경우 w=0일 때 물건의 개수와 value에 상관없이 모든 물건을 담을 수 없는데, 이때도 가방의 모든 value는 0이다.

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled%204.png)

저렇게 해서 재귀적으로 값을 구하면 된다.

참고로 값을 정할 때는 max로 비교하면 된다.

### bottom-up 방식

| n \ w | 0 | 1 | 2 | 3 | 4 | 5 |
| --- | --- | --- | --- | --- | --- | --- |
| 0 - | 0 | 0 | 0 | 0 | 0 | 0 |
| 1 A | 0 |  |  |  |  |  |
| 2 AB | 0 |  |  |  |  |  |
| 3 ABC | 0 |  |  |  |  |  |
| 4 ABCD | 0 |  |  |  |  | t |

방금 위에서 우리는 초기값이 0임을 구했다.

이 초기값을 기반으로 하나씩 채워나가면 된다.

top-down방식과 유사하게, $F(n, w)=\max\begin{cases}
F(n-1, w-w_n) + v_n \\
F(n-1, w) + 0
\end{cases}$ 의 식을 적용하면 된다.

즉 `F(n, w) = max(F(n-1, w-w[n]) + v[n], F(n-1, w))` 의 식으로 비교하면 된다.

참고로 이때 0보다 작은 인덱스를 참조하는 segmentation error: bad access가 일어나지 않게 조심하자. 만약 `??` 연산자를 지원하는 dart같은 언어는 딱히 신경쓸 필요 없이 `??` 를 쓰면 될 것이고, C++은 위 케이스의 경우 그대로 `F(n-1, w)` 으로 채우도록 코드를 작성했다.

```cpp
void knapsack_dp() {
    // itemIndex stands for column index
    for (int itemIndex = 1; itemIndex < items.size(); itemIndex++) {
      // weightIndex stands for row index
      for (int weightIndex = 1; weightIndex < maxWeight + 1; weightIndex++) {
        // for case of bad access
        if (weightIndex - items[itemIndex].getWeight() < 0) {
          dp[itemIndex][weightIndex] = dp[itemIndex - 1][weightIndex];
          continue;
        }
        **dp[itemIndex][weightIndex] = std::max(
            dp[itemIndex - 1][weightIndex], // NS(n-1, w) + 0
            dp[itemIndex - 1][weightIndex - items[itemIndex].getWeight()]
                + items[itemIndex].getValue() // NS(n-1, w - w[n]) + v[n]**
        );
      }
    }
  }
```

bottom up 방식은 [12865 평범한 배낭 (dp)](https://www.notion.so/12865-dp-1036edee84a744899c9e048a61fc9a4d) 이 링크를 보면 더 많이 알 수 있다.

# 총평 및 후기, 배운 점

![Untitled](./12865%EB%B2%88%20%ED%8F%89%EB%B2%94%ED%95%9C%20%EB%B0%B0%EB%82%AD/Untitled%205.png)

처음으로 풀어본 이차원 DP 문제였는데, 이전에 알골 스터디에서 재현이 형의 명강의를 들었어도 어떻게 푸는 지 가물가물… 강의를 들어도 헷갈리고… 그러다가 노션에 정리를 하면서 방금 이 문제를 완전히 이해하게 됐다! 역시 사람은 정리를 해야 문제를 이해하게 된다.

아무래도 이제는 많이 나아졌지만, C++은 2차원 벡터를 다루는데 있어 순간순간 멈칫하게 된다. 요새 슬슬 파이썬으로 갈아탈까 고민되는 중이긴 하다. 특히 C++은 `??` 연산자가 지원되지 않아서, 이 기능을 쓰려면 매우 제한적으로 사용해야 하는데 ( `std::optional` 이라는 타입이 있기는 한데 단 한 번도 사용해본 적도, 사용하는 걸 본 적도 없다 ), 그래서 배열 인덱스가 넘어가는 것을 방지하기 위해서 고민을 많이 해야 했다. 푸는 방법을 알아도 이런데서 시간을 많이 소모하였다.