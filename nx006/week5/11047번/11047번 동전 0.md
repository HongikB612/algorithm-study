# 11047번 동전 0

난이도: 실버 4
알고리즘 분류: 그리디
언어: C++
주차: 2G/5주차
풀이 날짜: 2023년 4월 4일

### 목차

# 문제

<문제 링크></문제 링크>

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 256 MB | 114046 | 114046 | 114046 | 52.006% |

### 문제

---

준규가 가지고 있는 동전은 총 N종류이고, 각각의 동전을 매우 많이 가지고 있다.

동전을 적절히 사용해서 그 가치의 합을 K로 만들려고 한다. 이때 필요한 동전 개수의 최솟값을 구하는 프로그램을 작성하시오.

### 입력

---

첫째 줄에 N과 K가 주어진다. (1 ≤ N ≤ 10, 1 ≤ K ≤ 100,000,000)

둘째 줄부터 N개의 줄에 동전의 가치 $A_i$가 오름차순으로 주어진다. (1 ≤ $A_i$ ≤ 1,000,000, $A_1$ = 1, i ≥ 2인 경우에 $A_i$는 $A_{i-1}$의 배수)

### 출력

---

첫째 줄에 K원을 만드는데 필요한 동전 개수의 최솟값을 출력한다.

### 예제 입력 1

---

```
10 4200
1
5
10
50
100
500
1000
5000
10000
50000
```

### 예제 출력 1

---

```
6
```

### 예제 입력 2

---

```
10 4790
1
5
10
50
100
500
1000
5000
10000
50000
```

### 예제 출력 2

---

```
12
```

# 풀이

- 전체 코드
    
    ```cpp
    
    ```
    

그리디 문제입니다.

받은 동전들을 큰 순서대로 정렬한 후, 동전의 값만큼 K를 나눠서 동전의 개수를 더해갈 수 있습니다.

예를 들어서 예제 1번의 경우, 다음과 같이 풀이할 수 있습니다.

| remain | / cost | count |
| --- | --- | --- |
| 4200 | 1000 | 4 |
| 200 | 100 | 2 |

총합 6

`std::vector`를 이용했으며, 원래는 내림차순으로 정렬하는게 자연스럽지만, `pop_back` 을 이용할 것이였어서 오름차순으로 정렬했습니다. 벡터에서 `pop_front` 을 사용해서 같은 문제를 해결하려면 O(N!)의 시간이 곱해졌을 겁니다.

```cpp
		std::sort(coins.begin(), coins.end());

    auto coinCount = 0;
    auto remainCost = targetCost;
    while(remainCost != 0)
    {
        coinCount += remainCost / coins.back();
        remainCost %= coins.back();
        coins.pop_back();
    }
```

# 총평 및 후기, 배운 점

사실 엄청 쉬운 문제여서 양심에 찔리긴 하는데, 이번 주차는 이걸로 넘어가겠습니다…