# 2910번 빈도 정렬

난이도: 실버 3
알고리즘 분류: 정렬, 해시맵
언어: C++
주차: 2G/4주차
풀이 날짜: 2023년 3월 22일

### 목차

# 문제

[https://www.acmicpc.net/problem/2910](https://www.acmicpc.net/problem/2910)

| 시간 제한 | 메모리 제한 | 제출 | 정답 | 맞힌 사람 | 정답 비율 |
| --- | --- | --- | --- | --- | --- |
| 1 초 | 128 MB | 6380 | 3233 | 2549 | 50.606% |

### 문제

---

위대한 해커 창영이는 모든 암호를 깨는 방법을 발견했다. 그 방법은 빈도를 조사하는 것이다.

창영이는 말할 수 없는 방법을 이용해서 현우가 강산이에게 보내는 메시지를 획득했다. 이 메시지는 숫자 N개로 이루어진 수열이고, 숫자는 모두 C보다 작거나 같다. 창영이는 이 숫자를 자주 등장하는 빈도순대로 정렬하려고 한다.

만약, 수열의 두 수 X와 Y가 있을 때, X가 Y보다 수열에서 많이 등장하는 경우에는 X가 Y보다 앞에 있어야 한다. 만약, 등장하는 횟수가 같다면, 먼저 나온 것이 앞에 있어야 한다.

이렇게 정렬하는 방법을 빈도 정렬이라고 한다.

수열이 주어졌을 때, 빈도 정렬을 하는 프로그램을 작성하시오.

### 입력

---

첫째 줄에 메시지의 길이 N과 C가 주어진다. (1 ≤ N ≤ 1,000, 1 ≤ C ≤ 1,000,000,000)

둘째 줄에 메시지 수열이 주어진다.

### 출력

---

첫째 줄에 입력으로 주어진 수열을 빈도 정렬한 다음 출력한다.

### 예제 입력 1

---

```
5 2
2 1 2 1 2
```

### 예제 출력 1

---

```
2 2 2 1 1
```

### 예제 입력 2

---

```
9 3
1 3 3 3 2 2 2 1 1
```

### 예제 출력 2

---

```
1 1 1 3 3 3 2 2 2
```

### 예제 입력 3

---

```
9 77
11 33 11 77 54 11 25 25 33
```

### 예제 출력 3

---

```
11 11 11 33 33 25 25 77 54
```

# 풀이

Hashmap을 이용하면 풀이 방법 자체는 간단하다.

해시맵을 이용해서, hashmap<value, count> 형태로 입력을 받는다.

각 value를 만날 때마다 +1을 더해주면 끝나는 문제이다.

다만 C++에서는 주의해야 할 점들이 몇 가지 있다.

1. `std::unordered_map`을 이용할 경우, 입력 순서에 대한 메모리를 따로 저장해야 한다.

이건 `std::map`을 이용할 때에도 마찬가지이다. 입력 순서에 대한 메모리를 따로 저장해야 한다. 나같은 경우, 전역 변수로 `static std::unordered_map<__int64 , __int64> inputOrder;`를 따로 만들어서 입력 순서를 저장했다.

```cpp
for (auto i = 0; i < N; i++) {
    __int64 inputValue = 0;
    std::cin >> inputValue;
    frequency[inputValue]++;
    **if (inputOrder[inputValue] == 0) {
      inputOrder[inputValue] += ++inputCount; // 입력 순서를 저장
    }**
  }
```

1. `reserve`를 할 경우 메모리 초과가 날 수 있다.

계속 메모리 초과가 나길래 대체 무슨 문제지? 하고 봤는데, 혹시나 해서 `frequency.reserve(maxValue)`를 지웠더니 AC를 받았다.

사실 maxValue로 reserve를 한 이유가 1부터 maxValue(C)까지 C개의 원소가 key로 저장될 수 있기 때문인데, 이 방법의 함정이 뭐냐면, 먼저 C개의 원소가 실제로 저장될 경우의 수도 적다는 것이고, 그리고 C가 최대 10억 개까지 input으로 들어올 수 있기 때문이다. 10억 개의 `<int, int>` 형식으로 된 pair가 저장된다고 생각해보자. 단순 계산으로도 8기가 바이트가 들어온다. 거기다가 `std::unordered_map` 객체가 예약되는 것이니 더 클 수도 있다. 심지어 16GB 램을 가진 컴퓨터에서도 8기가 바이트의 램이 갑자기 예약된다고 생각하면 뻗을 수 있다. 당연히 메모리 초과가 나는 게 당연하다.

# 총평 및 후기, 배운 점

![Untitled](./2910%EB%B2%88%20%EB%B9%88%EB%8F%84%20%EC%A0%95%EB%A0%AC/Untitled.png)

아무 생각 없이 `reserve`를 했는데, `reserve`를 하는 가장 큰 이유는 데이터의 전체적인 크기를 알고, 이에 맞추어서 최적화를 할 수 있기 때문이다. 지금같은 경우 데이터의 크기를 전체적으로 추산하지도 않았고, 그 크기가 메모리 초과를 일으킬 정도로 크다는 생각 자체를 빼먹었다. 데이터의 크기를 체크하는 것은 백준 풀 때는 사소할 수도 있는 문제지만 실무에 가면 중요한 행동이라 한다. 주의해야겠다.